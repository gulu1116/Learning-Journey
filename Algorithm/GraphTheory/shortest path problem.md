
## 最短路

n 为点数，m 为边数

### 一、单源最短路

- 求一个点到其他所有点的最短距离
  - 所有边的权重都是正数
    - 朴素 `Dijkstra` 算法
      - O(n^2)
      - 稠密图，边数 m 较多的时候
    - 堆优化版的 `Dijkstra` 算法
      - O(mlogn)
  - 存在负权边
    - `Bellman-Ford`
      - O(nm)
    - `SPFA`
      - 一般是 O(m) 
      - 最坏是 O(nm)
      - 不含任何负环

#### 1.1 朴素 `Dijkstra` 算法

>稠密图
>邻接矩阵

```c
S: 当前已经确定最短距离的点

1. dist[1] = 0, dist[i] = +∞
2. for (i: 0~n)
        t <-- 不在 S 中的距离最近的点
        S <-- t
        用 t 来更新其它点的距离
```

#### 1.2 堆优化版Dijkstra

>稀疏图

邻接表

算法的实现：
1. 初始化所有距离为无穷大，起点距离为0。
2. 使用小根堆（优先队列）存储（距离，节点），每次取出距离最小的节点。
3. 如果该节点已经处理过（已经确定了最短距离），则跳过；否则标记为已处理。
4. 遍历该节点的所有邻接边，尝试更新邻接点的距离。如果更新成功，则将新的距离和节点入堆。
5. 最后判断终点n的距离，若仍为初始值则说明不可达，返回-1；否则返回最短距离。
注意：这里使用堆优化Dijkstra算法，时间复杂度为O(m log n)。


#### 1.3 `Bellman-Ford`算法

```c
for n 次
    for 所有边 a, b, w
        dist[b] = min(dist[b], dist[a] + w)
```

三角不等式：
    dist[b] <= dist[a] + w

这里的备份可以理解为，当前只限制在原来基础上走1步，如果用刚刚更新了 dist，再去更新新的距离，那新的最短距离就不是新增1步得到的了

**关键点**

- **负权环**：Bellman-Ford 算法能够检测图中是否存在负权环。如果 `dist[]` 数组经过 `k` 次松弛操作后没有发生变化，则说明没有负权环。
- **时间复杂度**：Bellman-Ford 算法的时间复杂度是 **O(k * m)**，其中 `k` 是松弛操作的次数，`m` 是边的数量。对于 **一般图**，`k` 等于节点数 `n`，因此时间复杂度为 **O(n * m)**。


#### 1.4 `SPFA` 算法

- **保证不存在负权回路**

```c
  queue <-- 1（起点）
  while queue 不空
    1. t <-- q.front
        q.pop
    2. 更新 t 的所有出边 t -w-> b
        queue <-- b

```

#### 1.5 `Bellman-Ford` 与 `SPFA` 对比

| 项目         | **Bellman-Ford**       | **SPFA（Shortest Path Faster Algorithm）** |
| ---------- | ---------------------- | ---------------------------------------- |
| **基本思想**   | 每次“暴力”遍历所有边，尝试松弛更新     | 从源点出发，**只扩展有可能被更新的点**，以队列优化              |
| **遍历对象**   | 每轮遍历所有边                | 每轮只遍历队列中的点的所有邻边                          |
| **更新机制**   | 无论是否可能更新，都强制尝试松弛       | 只有当某个点的距离被更新，才会将其加入队列、扩展其邻居              |
| **循环次数**   | 最多进行 n−1 轮（n 为点数）      | 直到队列为空，理论上轮数不确定                          |
| **是否剪枝**   | 不剪枝，盲目遍历所有边            | 有剪枝，只处理可能更新的点，提高效率                       |
| **时间复杂度**  | 最坏 O(n×m)（n 为点数，m 为边数） | 最坏也是 O(n×m)，但**实际效率远高于 Bellman-Ford**    |
| **适用图**    | 可以处理负权图（不能有负环）         | 也可处理负权图，负环检测需额外判断入队次数                    |
| **是否容易超时** | 相对容易（尤其是稠密图）           | 更不容易超时，适用于稠密或稀疏图                         |




#### 1.6 SPFA 与其他算法的适用性对比：

| 算法           | 适用图类型      | 时间复杂度（最坏）           | 优势         | 劣势                 |
| ------------ | ---------- | ------------------- | ---------- | ------------------ |
| **BFS**      | 无权图（边权全为1） | O(n + m)            | 简单、快       | 只适用于边权为1的图         |
| **Dijkstra** | 非负权图       | O((n + m)logn)（堆优化） | 高效、稳定、最常用  | 不能处理负权边            |
| **SPFA**     | 任意权图（允许负边） | O(km)，最坏O(nm)       | 实现简单、适用范围广 | 在某些图上退化到极慢（n²\~nm） |

#### 1.7 SPFA 流程 vs Dijkstra vs BFS 流程（总结对比）

| 步骤     | SPFA                          | Dijkstra（堆优化）                 | BFS（无权图）              |
| ------ | ----------------------------- | ----------------------------- | --------------------- |
| 初始     | 所有点距离设为∞，源点设为0入队              | 所有点距离设为∞，源点设为0入堆              | 所有点距离设为-1，源点设为0入队     |
| 选点方式   | 队列中取出（可能重复）                   | 堆中取出当前最小值点（只处理一次）             | 队列中先进先出处理             |
| 松弛条件   | 若 `dist[u] + w < dist[v]` 则更新 | 若 `dist[u] + w < dist[v]` 则更新 | 若 `dist[v] == -1` 则更新 |
| 再次入队/堆 | 更新后如未在队列中就入队                  | 更新后入堆                         | 更新后直接入队               |
| 出队次数   | 最多 n 次（理想）～ nm 次（最坏）          | 每个点只处理一次                      | 每个点只处理一次              |


### 二、多源汇最短路

源点：起点
汇点：终点

- `Floyd`算法
  - O(n^3)

- **Floyd-Warshall 算法：**
    
    - 使用三重循环进行 **松弛操作**：
        - 外层循环遍历所有的中间节点 `k`。
        - 中间两层循环遍历所有的起点 `i` 和终点 `j`，通过节点 `k` 更新从 `i` 到 `j` 的最短路径。
        - 如果从 `i` 到 `j` 经过 `k` 节点的路径更短，更新 `d[i][j]` 为新的更短路径。
      
      
**总结**
- **Floyd-Warshall 算法**是一种 **动态规划算法**，用于计算所有节点对之间的最短路径。
- 该算法适用于 **稠密图**，当边数 `m` 较大时，算法的时间复杂度为 **O(n³)**，其中 `n` 是节点数。
- 对于查询，算法通过存储的最短路径矩阵 `d[][]` 可以在 **O(1)** 时间内快速返回答案。